/*
 * Nickolas Schiffer #012279319
 * CMPE 146 S19
 * Lab: ADC_PWM part 0
 * Ch. 29 of LPC17xx datasheet
 */

#include <stdlib.h>
#include <LPC17xx.h>
#include <tasks.hpp>
#include <stdio.h>
#include "ADC/adcDriver.hpp"
#include "PWM/pwmDriver.hpp"
#include <math.h>

#define VREF 3.3


uint16_t adc_read_channel(uint8_t channel){
    if (!((channel >= 0) && (channel <= 7))){
        printf("Invalid param\n");
        return 0xFFFF;
    }
    LPC_ADC->ADCR |= (1 << channel);
    return (uint16_t)(LPC_ADC->ADGDR >> 4);
}

void vLightSensorPrint(void *pvParameters){
    /*
    * 1) Initial ADC setup (Power, clkselect, pinselect, clkdivider)
    * 2) Select ADC channel 2
    * 3) Enable burst mode
    */
    /*
     * Set pin 0.25 to ADC0.2
     */
    LPC_PINCON->PINSEL1 |= (1 << 18);

    /*
     * Initialize ADC Power
     */
    LPC_SC->PCONP |= (1 << pconp_adc);
    /*
     * Select pin 2 to be converted (hardwired to light sensor): bits 7:0
     */
    LPC_ADC->ADCR |= (1 << 2);
    /*
     * Set clock divider (should be <= 13MHz) -> 48Mhz / 4 = 12Mhz: bits 15:8
     */
    LPC_ADC->ADCR |= (4 << 8);
    /*
     * Enable Burst Mode: bit 16
     */
    LPC_ADC->ADCR |= (1 << 16);
    /*
     * Enable ADC Operational State: pin 21
     */
    LPC_ADC->ADCR |= (1 << 21);



    while(1) {
        uint16_t ls_val = adc_read_channel(2);
        printf("Light Sensor value is %d\n", ls_val);
        vTaskDelay(100);
    }
}

void vADCDriverTest(void *pvParameters){
    auto adc = LabAdc();
    adc.AdcSelectPin(LabAdc::k0_25);
    adc.AdcSelectPin(LabAdc::k0_26);
    adc.AdcInitBurstMode();
    float voltage2, voltage3;

    while (1){
        voltage2 = adc.ReadAdcVoltageByChannel(LabAdc::channel_2);
        voltage3 = adc.ReadAdcVoltageByChannel(LabAdc::channel_3);
        printf("channel 2 voltage: %fV\n", voltage2);
        printf("channel 3 voltage: %fV\n\n", voltage3);
        vTaskDelay(100);
    }
}

void vPWMDriverTest(void *pvParameters){
    auto pwm = LabPwm();
    pwm.PwmInitSingleEdgeMode(5000);
    //pwm.PwmSelectPin(LabPwm::k2_1);
    pwm.PwmSelectAllPins();
    //pwm.SetFrequency(1);

    float duty_cycle = 0.5;
    while (1){
        while (duty_cycle >= 0.01){
        pwm.SetDutyCycle(LabPwm::k2_0, duty_cycle);
        pwm.SetDutyCycle(LabPwm::k2_1, duty_cycle);
        pwm.SetDutyCycle(LabPwm::k2_2, duty_cycle);
        pwm.SetDutyCycle(LabPwm::k2_3, duty_cycle);
        pwm.SetDutyCycle(LabPwm::k2_4, duty_cycle);
        duty_cycle -= 0.01;
        vTaskDelay(10);
        }

    while (duty_cycle <= 1){
        pwm.SetDutyCycle(LabPwm::k2_0, duty_cycle);
        pwm.SetDutyCycle(LabPwm::k2_1, duty_cycle);
        pwm.SetDutyCycle(LabPwm::k2_2, duty_cycle);
        pwm.SetDutyCycle(LabPwm::k2_3, duty_cycle);
        pwm.SetDutyCycle(LabPwm::k2_4, duty_cycle);
        duty_cycle += 0.01;
        vTaskDelay(10);
    }
    }


}

void vPWMADCTEST(void *pvParameters){
    auto pwm = LabPwm();
    auto adc = LabAdc();

    adc.AdcSelectPin(LabAdc::k0_26);
    adc.AdcInitBurstMode();

    pwm.PwmSelectPin(LabPwm::k2_0);
    pwm.PwmInitSingleEdgeMode(100);
    float voltage, duty_cycle;

    while (1){

        voltage = adc.ReadAdcVoltageByChannel(LabAdc::channel_3);
        duty_cycle = (float)(voltage / (float)VREF);
        pwm.SetDutyCycle(LabPwm::k2_0,duty_cycle);
//        printf("voltage: %f\n\n", voltage);
//        printf("duty cycle: %f\n\n", duty_cycle);
        vTaskDelay(1);
    }


}

float map(float x, float in_min, float in_max, float out_min, float out_max){
    return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

void vRGBTEST(void *pvParamters){
    auto pwm = LabPwm();
    pwm.PwmSelectPin(LabPwm::k2_0);
    pwm.PwmSelectPin(LabPwm::k2_1);
    pwm.PwmSelectPin(LabPwm::k2_2);
    pwm.PwmInitSingleEdgeMode(100);

    auto adc = LabAdc();
    adc.AdcSelectPin(LabAdc::k0_26);
    adc.AdcInitBurstMode();

    float duty_cycle_red, duty_cycle_green, duty_cycle_blue, voltage;
    uint16_t delay = 1;

    while(1){
        //duty_cycle_red = duty_cycle_green = duty_cycle_blue = 0;

        for (double x = 0; x < 360; x+=delay){
            voltage = adc.ReadAdcVoltageByChannel(LabAdc::channel_3);
            delay = (uint16_t)map(voltage, 0, 3.3, 1, 50);
            printf("voltage %f\ndelay: %u\n", voltage, delay);

            duty_cycle_red   = (float)((1*(sin((double)(x/180*M_PI))+1))/2);
            duty_cycle_green = (float)((1*(sin((double)(x/180*M_PI+((double)(1.5)*M_PI)))+1))/2);
            duty_cycle_blue  = (float)((1*(sin((double)(x/180*M_PI+((double)(0.5)*M_PI)))+1))/2);
            pwm.SetDutyCycle(LabPwm::k2_0,duty_cycle_red);
            pwm.SetDutyCycle(LabPwm::k2_1,duty_cycle_green);
            pwm.SetDutyCycle(LabPwm::k2_2,duty_cycle_blue);
            printf("r: %f\ng: %f\nb: %f\n\n", duty_cycle_red, duty_cycle_green, duty_cycle_blue);
            vTaskDelay(10);
        }


        }


}


int main(){
    scheduler_add_task(new terminalTask(PRIORITY_HIGH));

    //xTaskCreate(vLightSensorPrint, "LightSensorPrint", 1024, NULL, PRIORITY_LOW, NULL);
//    xTaskCreate(vADCDriverTest, "ADCDriverTest", 1024, NULL, PRIORITY_LOW, NULL);
//    xTaskCreate(vPWMDriverTest, "PWMDriverTest", 1000, NULL, PRIORITY_LOW, NULL);
//    xTaskCreate(vPWMADCTEST, "PWMADCTest", 1000, NULL, PRIORITY_LOW, NULL);
    xTaskCreate(vRGBTEST, "RGBTest", 1000, NULL, PRIORITY_LOW, NULL);

    scheduler_start();
    return EXIT_FAILURE;
}
